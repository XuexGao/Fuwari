name: auto-pr

on:
  pull_request_target:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: auto-pr-${{ github.event.pull_request.number || github.event.issue.number }}
  cancel-in-progress: true

jobs:
  triage:
    if: ${{ github.event_name == 'pull_request_target' }}
    runs-on: ubuntu-latest
    steps:
      - name: Label PR by changed paths
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT }}
          script: |
            const owner = context.repo.owner
            const repo = context.repo.repo
            const pull_number = context.payload.pull_request.number

            const LABEL_FRIEND = 'å‹é“¾'
            const LABEL_SPONSOR = 'èµåŠ©'
            const LABEL_AVATAR_OK = 'å¤´åƒå¯è¾¾'
            const LABEL_AVATAR_BAD = 'å¤´åƒä¸å¯è¾¾'
            const LABEL_SITE_OK = 'ç½‘ç«™å¯è¾¾'
            const LABEL_SITE_BAD = 'ç½‘ç«™ä¸å¯è¾¾'
            const LABEL_ALL_OK = 'URLå…¨éƒ¨å¯è¾¾'
            const LABEL_BIDIR = 'åŒå‘é“¾æ¥éªŒè¯'
            const LABEL_BIDIR_OK = 'åŒå‘é“¾æ¥éªŒè¯é€šè¿‡'

            async function ensureLabel(name) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name })
              } catch (e) {
                if (e.status !== 404) throw e
                await github.rest.issues.createLabel({
                  owner,
                  repo,
                  name,
                  color: 'ededed',
                })
              }
            }

            async function listAllFiles() {
              const files = []
              for await (const res of github.paginate.iterator(
                github.rest.pulls.listFiles,
                { owner, repo, pull_number, per_page: 100 }
              )) {
                for (const f of res.data) files.push(f)
              }
              return files
            }

            const files = await listAllFiles()

            if (files.length !== 1) {
              await createComment('PR å¿…é¡»ä»…åŒ…å«ä¸€ä¸ªæ–‡ä»¶å˜æ›´ã€‚')
              return
            }
            const file = files[0]
            if (!file.filename.startsWith('src/data/friends/') && !file.filename.startsWith('src/data/sponsors/')) {
              await createComment('åªå…è®¸æ›´æ”¹ src/data/friends/ æˆ– src/data/sponsors/ ä¸‹çš„æ–‡ä»¶ã€‚')
              return
            }
            if (file.status !== 'added' && file.status !== 'modified') {
              await createComment('åªå…è®¸æ–°å¢æˆ–ç¼–è¾‘æ–‡ä»¶ã€‚')
              return
            }

            const paths = files.map((f) => f.filename)
            const touchedFriends = file.filename.startsWith('src/data/friends/')
            const touchedSponsors = file.filename.startsWith('src/data/sponsors/')

            for (const name of [
              LABEL_FRIEND,
              LABEL_SPONSOR,
              LABEL_AVATAR_OK,
              LABEL_AVATAR_BAD,
              LABEL_SITE_OK,
              LABEL_SITE_BAD,
              LABEL_ALL_OK,
              LABEL_BIDIR,
              LABEL_BIDIR_OK,
            ]) {
              await ensureLabel(name)
            }

            const add = []
            const remove = []
            if (touchedFriends) add.push(LABEL_FRIEND)
            if (touchedSponsors) add.push(LABEL_SPONSOR)
            if (touchedFriends && !touchedSponsors) remove.push(LABEL_SPONSOR)
            if (touchedSponsors && !touchedFriends) remove.push(LABEL_FRIEND)

            if (add.length) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: pull_number, labels: add })
            }
            for (const name of remove) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: pull_number, name })
              } catch (e) {
                if (e.status !== 404) throw e
              }
            }

            async function createComment(body) {
              const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              const footer = `\n\n---\nè¯¥è¯„è®ºç”± Action è‡ªåŠ¨åŒ–å‘é€ï¼Œæ— éœ€å›å¤ã€‚\n\nğŸ”— [æŸ¥çœ‹ Action](${runUrl})`
              const fullBody = body + footer
              core.info(`createComment len=${String(fullBody || '').length}`)
              try {
                await github.rest.issues.createComment({ owner, repo, issue_number: pull_number, body: fullBody })
                core.info('createComment ok')
              } catch (e) {
                core.error(`createComment failed: status=${e?.status || ''}`)
                core.error(`createComment failed: message=${e?.message || e}`)
                try {
                  core.error(`createComment failed: response=${JSON.stringify(e?.response?.data || null)}`)
                } catch {}
                throw e
              }
            }

            function isNonEmptyString(v) {
              return typeof v === 'string' && v.trim().length > 0
            }

            function parseJsonSafe(text) {
              try {
                return { ok: true, value: JSON.parse(text) }
              } catch (e) {
                return { ok: false, error: e?.message || String(e) }
              }
            }

            async function getTextFileFromRepo(path, ref) {
              const res = await github.rest.repos.getContent({ owner, repo, path, ref })
              if (Array.isArray(res.data) || !res.data?.content) throw new Error(`Invalid content response for ${path}`)
              const raw = Buffer.from(res.data.content, res.data.encoding || 'base64').toString('utf8')
              return raw
            }

            async function getSiteBase() {
              try {
                const raw = await getTextFileFromRepo('astro.config.mjs', context.payload.repository.default_branch)
                const m = raw.match(/\bsite\s*:\s*["']([^"']+)["']/)
                if (!m) return null
                return m[1]
              } catch (e) {
                core.warning(`Failed to read astro.config.mjs: ${e?.message || e}`)
                return null
              }
            }

            const siteBase = await getSiteBase()

            function normalizeUrl(rawUrl) {
              if (!isNonEmptyString(rawUrl)) return null
              const u = rawUrl.trim()
              if (u.startsWith('/')) {
                if (!siteBase) return null
                return new URL(u, siteBase).toString()
              }
              try {
                return new URL(u).toString()
              } catch {
                return null
              }
            }

            async function checkUrl(url, { timeoutMs }) {
              const controller = new AbortController()
              const timer = setTimeout(() => controller.abort(), timeoutMs)
              try {
                const res = await fetch(url, {
                  method: 'GET',
                  redirect: 'follow',
                  headers: {
                    'user-agent': 'fuwari-auto-pr/1.0 (+github actions)',
                    accept: 'text/html,application/json,image/*,*/*;q=0.8',
                  },
                  signal: controller.signal,
                })
                return { ok: res.status >= 200 && res.status < 400, status: res.status }
              } catch (e) {
                return { ok: false, error: e?.message || String(e) }
              } finally {
                clearTimeout(timer)
              }
            }

            async function setLabels({ addLabels, removeLabels, skipIfSame }) {
              const addSet = new Set(addLabels || [])
              const removeSet = new Set(removeLabels || [])
              for (const x of addSet) removeSet.delete(x)

              const current = await github.rest.issues.get({ owner, repo, issue_number: pull_number })
              const currentLabels = new Set((current.data.labels || []).map((l) => l.name))

              if (skipIfSame) {
                for (const name of addSet) {
                  if (currentLabels.has(name)) {
                    core.info(`Label ${name} already set, skip label operations`)
                    return
                  }
                }
              }

              const finalRemove = Array.from(removeSet).filter((name) => currentLabels.has(name))
              if (finalRemove.length) {
                for (const name of finalRemove) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: pull_number, name })
                  } catch (e) {
                    if (e.status !== 404) throw e
                  }
                }
              }

              const finalAdd = Array.from(addSet).filter((name) => !currentLabels.has(name))
              if (finalAdd.length) {
                await github.rest.issues.addLabels({ owner, repo, issue_number: pull_number, labels: finalAdd })
              }
            }

            const relevant = files.filter((f) => {
              if (f.status === 'removed') return false
              if (f.filename.startsWith('src/data/friends/')) return true
              if (f.filename.startsWith('src/data/sponsors/')) return true
              return false
            })

            const invalidSuffix = relevant.filter((f) => !f.filename.endsWith('.json')).map((f) => f.filename)
            if (invalidSuffix.length) {
              await createComment(
                [
                  'æ£€æµ‹åˆ°å‹é“¾/èµåŠ©ç›®å½•ä¸‹å­˜åœ¨é .json æ–‡ä»¶ï¼Œå·²åœæ­¢å¤„ç†ï¼š',
                  '',
                  ...invalidSuffix.map((p) => `- ${p}`),
                ].join('\n')
              )
              return
            }

            const headSha = context.payload.pull_request.head.sha
            const parsedEntries = []
            const errors = []

            for (const f of relevant) {
              const raw = await getTextFileFromRepo(f.filename, headSha)
              const parsed = parseJsonSafe(raw)
              if (!parsed.ok) {
                errors.push(`${f.filename}: JSON è§£æå¤±è´¥ï¼ˆ${parsed.error}ï¼‰`)
                continue
              }
              if (!parsed.value || typeof parsed.value !== 'object' || Array.isArray(parsed.value)) {
                errors.push(`${f.filename}: JSON å¿…é¡»æ˜¯å¯¹è±¡`)
                continue
              }

              const kind = f.filename.startsWith('src/data/friends/') ? 'friend' : 'sponsor'
              parsedEntries.push({ path: f.filename, kind, data: parsed.value })
            }

            function validateEntry({ kind, data, path }) {
              const entryErrors = []
              if (!isNonEmptyString(data.name)) entryErrors.push('name å¿…å¡«')
              if (!isNonEmptyString(data.avatar)) entryErrors.push('avatar å¿…å¡«')
              if (kind === 'friend') {
                if (!isNonEmptyString(data.url)) entryErrors.push('url å¿…å¡«')
              }
              if (kind === 'sponsor') {
                if (!isNonEmptyString(data.date)) entryErrors.push('date å¿…å¡«')
                if (!isNonEmptyString(data.amount)) entryErrors.push('amount å¿…å¡«')
              }
              if (entryErrors.length) return `${path}: ${entryErrors.join('ã€')}`
              return null
            }

            for (const e of parsedEntries) {
              const err = validateEntry(e)
              if (err) errors.push(err)
            }

            if (errors.length) {
              await createComment(['æ£€æµ‹åˆ°æ•°æ®æ–‡ä»¶æ ¡éªŒå¤±è´¥ï¼š', '', ...errors.map((x) => `- ${x}`)].join('\n'))
              return
            }

            const vipPaths = parsedEntries
              .filter((e) => Object.prototype.hasOwnProperty.call(e.data, 'vip'))
              .map((e) => e.path)
            if (vipPaths.length) {
              await createComment(
                [
                  'æ£€æµ‹åˆ° JSON å­˜åœ¨ vip å­—æ®µï¼Œå·²ç»ˆæ­¢è‡ªåŠ¨æµç¨‹ã€‚',
                  '',
                  'è¯·ä»ä»¥ä¸‹æ–‡ä»¶ç§»é™¤ vip å­—æ®µåå† push æ›´æ–°ï¼ˆç§»é™¤åæ‰ä¼šç»§ç»­è‡ªåŠ¨æ ¡éªŒ/è‡ªåŠ¨åˆå¹¶ï¼‰ï¼š',
                  '',
                  ...vipPaths.map((p) => `- ${p}`),
                ].join('\n')
              )
              return
            }

            const primaryKind = touchedSponsors ? 'sponsor' : 'friend'
            const primary = parsedEntries.find((e) => e.kind === primaryKind) || parsedEntries[0]

            await github.rest.pulls.update({
              owner,
              repo,
              pull_number,
              title: `${primary.kind === 'friend' ? 'å‹é“¾' : 'èµåŠ©'}ï¼š${primary.data.name}`,
            })

            const avatarUrl = normalizeUrl(primary.data.avatar)
            const siteUrl = normalizeUrl(primary.data.url)
            const selfSite = siteBase ? siteBase.replace(/\/$/, '') : null
            const normalizedSiteUrl = siteUrl ? siteUrl.replace(/\/$/, '') : null
            const normalizedBacklinkRaw = isNonEmptyString(primary.data.backlink) ? primary.data.backlink.trim() : null
            const normalizedBacklinkUrl = normalizedBacklinkRaw
              ? (() => {
                  try {
                    return new URL(normalizedBacklinkRaw).toString().replace(/\/$/, '')
                  } catch {
                    return null
                  }
                })()
              : null
            if (primary.kind === 'friend' && selfSite) {
              if (normalizedSiteUrl === selfSite) {
                await createComment(`æ£€æµ‹åˆ°å‹é“¾ JSON çš„ url æŒ‡å‘æœ¬ç«™ï¼ˆ${siteBase}ï¼‰ï¼Œè¯·å¡«å†™ä½ è‡ªå·±çš„ç½‘ç«™ URLã€‚`)
                return
              }
              if (normalizedBacklinkUrl === selfSite) {
                await createComment(`æ£€æµ‹åˆ°å‹é“¾ JSON çš„ backlink æŒ‡å‘æœ¬ç«™ï¼ˆ${siteBase}ï¼‰ï¼Œè¯·å¡«å†™ä½ è‡ªå·±ç½‘ç«™çš„å‹é“¾é¡µ URLã€‚`)
                return
              }
            }

            const avatarCheck = avatarUrl ? await checkUrl(avatarUrl, { timeoutMs: 10000 }) : { ok: false, error: 'Invalid avatar URL' }
            const siteCheck =
              primary.kind === 'friend'
                ? siteUrl
                  ? await checkUrl(siteUrl, { timeoutMs: 10000 })
                  : { ok: false, error: 'Invalid site URL' }
                : siteUrl
                  ? await checkUrl(siteUrl, { timeoutMs: 10000 })
                  : null

            const addReach = []
            const removeReach = [LABEL_AVATAR_OK, LABEL_AVATAR_BAD, LABEL_SITE_OK, LABEL_SITE_BAD, LABEL_ALL_OK]

            addReach.push(avatarCheck.ok ? LABEL_AVATAR_OK : LABEL_AVATAR_BAD)
            if (siteCheck) addReach.push(siteCheck.ok ? LABEL_SITE_OK : LABEL_SITE_BAD)

            const allOk = avatarCheck.ok && (!siteCheck || siteCheck.ok)
            if (allOk && siteCheck) addReach.push(LABEL_ALL_OK)

            await setLabels({ addLabels: addReach, removeLabels: removeReach, skipIfSame: true })

            const existingLabelNames = new Set((context.payload.pull_request.labels || []).map((l) => l.name))
            core.info(`bidir: event.action=${context.payload.action || ''}`)
            core.info(`bidir: siteBase=${siteBase || ''}`)
            core.info(`bidir: existingLabels=${Array.from(existingLabelNames).join(',')}`)
            if (primary.kind === 'friend') {
              if (!siteBase) {
                core.info('bidir: missing siteBase -> comment and return')
                await createComment('æ— æ³•è¯»å–æœ¬ç«™ site é…ç½®ï¼Œæ— æ³•è¿›è¡ŒåŒå‘é“¾æ¥éªŒè¯ã€‚')
                return
              }
              if (!existingLabelNames.has(LABEL_BIDIR) && !existingLabelNames.has(LABEL_BIDIR_OK)) {
                core.info('bidir: add LABEL_BIDIR')
                await github.rest.issues.addLabels({ owner, repo, issue_number: pull_number, labels: [LABEL_BIDIR] })
              }

              const expected = siteBase.replace(/\/$/, '')
              const backlink = primary.data.backlink
              core.info(`bidir: url=${String(siteUrl || '')}`)
              core.info(`bidir: backlink=${String(backlink || '')}`)

              if (!isNonEmptyString(backlink)) {
                core.info('bidir: missing backlink -> setLabels + comment')
                await setLabels({ addLabels: [LABEL_BIDIR], removeLabels: [LABEL_BIDIR_OK] })
                await createComment(
                  [
                    'åŸºç¡€æ ¡éªŒå·²é€šè¿‡ï¼Œéœ€è¦è¿›è¡ŒåŒå‘é“¾æ¥éªŒè¯ï¼š',
                    '',
                    `1) è¯·åœ¨ä½ çš„å‹é“¾é¡µé¢æ·»åŠ æœ¬ç«™å‹é“¾ï¼ˆå¿…é¡»ä¸ºç»å¯¹é“¾æ¥ï¼‰ï¼š${siteBase}`,
                    '2) ç„¶åæ›´æ–°æœ¬ PR çš„å‹é“¾ JSONï¼Œå¢åŠ å­—æ®µ backlinkï¼ˆå¡«å†™ä½ çš„å‹é“¾é¡µé¢ URLï¼Œå¿…é¡»æ˜¯ http/https ç»å¯¹é“¾æ¥ï¼‰',
                    '',
                    'ç¤ºä¾‹ï¼š',
                    '',
                    '```json',
                    '{',
                    '  "name": "...",',
                    '  "avatar": "...",',
                    '  "url": "...",',
                    '  "backlink": "https://example.com/friends/"',
                    '}',
                    '```',
                    '',
                    `3) è¯·ç¡®ä¿ä½ çš„ backlink é¡µé¢ä¸­åŒ…å«æŒ‡å‘æœ¬ç«™çš„é“¾æ¥ href=${siteBase} ï¼ˆå¿…é¡»å®Œå…¨ä¸€è‡´çš„ç»å¯¹é“¾æ¥ï¼‰`,
                    '4) push æ›´æ–°å Action ä¼šè‡ªåŠ¨é‡æ–°æ ¡éªŒå¹¶åœ¨é€šè¿‡åè‡ªåŠ¨åˆå¹¶ï¼Œæ— éœ€é¢å¤–è¯„è®º',
                  ].join('\n')
                )
                return
              }

              let backlinkUrl
              try {
                backlinkUrl = new URL(backlink).toString()
              } catch {
                core.info('bidir: backlink invalid url -> setLabels + comment')
                await setLabels({ addLabels: [LABEL_BIDIR], removeLabels: [LABEL_BIDIR_OK] })
                await createComment(`åŒå‘é“¾æ¥éªŒè¯å¤±è´¥ï¼šbacklink ä¸æ˜¯åˆæ³•çš„ URLï¼ˆ${backlink}ï¼‰`)
                return
              }
              if (!backlinkUrl.startsWith('http://') && !backlinkUrl.startsWith('https://')) {
                core.info('bidir: backlink not http(s) -> setLabels + comment')
                await setLabels({ addLabels: [LABEL_BIDIR], removeLabels: [LABEL_BIDIR_OK] })
                await createComment(`åŒå‘é“¾æ¥éªŒè¯å¤±è´¥ï¼šbacklink å¿…é¡»ä»¥ http/https å¼€å¤´ï¼ˆ${backlink}ï¼‰`)
                return
              }

              let siteUrlObj
              try {
                siteUrlObj = new URL(siteUrl)
              } catch {
                core.info('bidir: siteUrl invalid -> setLabels + comment')
                await setLabels({ addLabels: [LABEL_BIDIR], removeLabels: [LABEL_BIDIR_OK] })
                await createComment('åŒå‘é“¾æ¥éªŒè¯å¤±è´¥ï¼šå‹é“¾ JSON ä¸­ url æ— æ•ˆï¼Œæ— æ³•æ¯”è¾ƒä¸»åŸŸåã€‚')
                return
              }
              const backlinkHost = new URL(backlinkUrl).host.toLowerCase()
              const siteHost = siteUrlObj.host.toLowerCase()
              core.info(`bidir: host url=${siteHost} backlink=${backlinkHost}`)
              if (backlinkHost !== siteHost) {
                core.info('bidir: host mismatch -> setLabels + comment')
                await setLabels({ addLabels: [LABEL_BIDIR], removeLabels: [LABEL_BIDIR_OK] })
                await createComment(
                  [
                    'åŒå‘é“¾æ¥éªŒè¯å¤±è´¥ï¼šbacklink çš„ä¸»åŸŸåå¿…é¡»ä¸ url çš„ä¸»åŸŸåä¸€è‡´ã€‚',
                    '',
                    `urlï¼š${siteUrlObj.toString()}`,
                    `backlinkï¼š${backlinkUrl}`,
                  ].join('\n')
                )
                return
              }

                function extractTitle(html) {
                  if (!isNonEmptyString(html)) return null
                  const m = html.match(/<title[^>]*>([\s\S]*?)<\/title>/i)
                  if (!m) return null
                  const t = String(m[1] || '').replace(/\s+/g, ' ').trim()
                  return t.slice(0, 200)
                }

                function formatBacklinkDebug(d) {
                  const lines = ['è°ƒè¯•ä¿¡æ¯ï¼š']
                  if (isNonEmptyString(d?.finalUrl)) lines.push(`- æœ€ç»ˆ URLï¼š${d.finalUrl}`)
                  if (typeof d?.status === 'number') lines.push(`- çŠ¶æ€ç ï¼š${d.status}`)
                  if (isNonEmptyString(d?.contentType)) lines.push(`- Content-Typeï¼š${d.contentType}`)
                  if (isNonEmptyString(d?.title)) lines.push(`- æ ‡é¢˜ï¼š${d.title}`)
                  return lines.join('\n')
                }

                const fetched = await (async () => {
                  const controller = new AbortController()
                  const timer = setTimeout(() => controller.abort(), 10000)
                  try {
                    const res = await fetch(backlinkUrl, {
                      method: 'GET',
                      redirect: 'follow',
                      headers: { 'user-agent': 'fuwari-auto-pr/1.0 (+github actions)', accept: 'text/html,*/*;q=0.8' },
                      signal: controller.signal,
                    })
                    if (!res.ok) {
                      core.info(`bidir: fetch backlink not ok status=${res.status}`)
                      await setLabels({ addLabels: [LABEL_BIDIR], removeLabels: [LABEL_BIDIR_OK] })
                      await createComment(
                        [
                          `åŒå‘é“¾æ¥éªŒè¯å¤±è´¥ï¼šæ— æ³•è®¿é—® backlinkï¼ˆ${res.status}ï¼‰ã€‚`,
                          '',
                          `backlinkï¼š${backlinkUrl}`,
                          formatBacklinkDebug({
                            finalUrl: res.url,
                            status: res.status,
                            contentType: res.headers.get('content-type') || '',
                          }),
                        ].join('\n')
                      )
                      return { ok: false }
                    }
                    core.info('bidir: fetch backlink ok, read text')
                    const html = await res.text()
                    return {
                      ok: true,
                      html,
                      finalUrl: res.url,
                      status: res.status,
                      contentType: res.headers.get('content-type') || '',
                      title: extractTitle(html),
                    }
                  } catch (e) {
                    core.info(`bidir: fetch backlink threw: ${e?.message || e}`)
                    await setLabels({ addLabels: [LABEL_BIDIR], removeLabels: [LABEL_BIDIR_OK] })
                    await createComment(
                      [
                        'åŒå‘é“¾æ¥éªŒè¯å¤±è´¥ï¼šè®¿é—® backlink å‡ºé”™ã€‚',
                        '',
                        `backlinkï¼š${backlinkUrl}`,
                        `é”™è¯¯ï¼š${e?.message || e}`,
                      ].join('\n')
                    )
                    return { ok: false }
                  } finally {
                    clearTimeout(timer)
                  }
                })()
                if (!fetched.ok) return
                const html = fetched.html || ''
                core.info(`bidir: html length=${html.length}`)

                let found = false
                const re = /href\s*=\s*["']([^"']+)["']/gi
                let m
                while ((m = re.exec(html)) !== null) {
                  const href = (m[1] || '').trim()
                  if (!href.startsWith('http')) continue
                  const normalized = href.replace(/\/$/, '')
                  if (normalized === expected) {
                    found = true
                    break
                  }
                }
                core.info(`bidir: expected=${expected} found=${found}`)

                if (!found) {
                  core.info('bidir: not found -> setLabels + comment')
                  await setLabels({ addLabels: [LABEL_BIDIR], removeLabels: [LABEL_BIDIR_OK] })
                  await createComment(
                    [
                      'åŒå‘é“¾æ¥éªŒè¯æœªé€šè¿‡ï¼šåœ¨ backlink é¡µé¢æœªæ£€æµ‹åˆ°æœ¬ç«™å‹é“¾ã€‚',
                      '',
                      `éœ€è¦æ·»åŠ çš„ç»å¯¹é“¾æ¥ï¼š${siteBase}`,
                      `backlink é¡µé¢ï¼š${backlinkUrl}`,
                      '',
                      formatBacklinkDebug(fetched),
                      '',
                      'è¯·æ·»åŠ å push æ›´æ–°ï¼ˆæ— éœ€è¯„è®ºï¼‰ã€‚',
                    ].join('\n')
                  )
                  return
                }

                await setLabels({ addLabels: [LABEL_BIDIR_OK], removeLabels: [LABEL_BIDIR] })
                core.info('bidir: verified ok -> merge')

                try {
                  await github.rest.pulls.merge({ owner, repo, pull_number, merge_method: 'squash' })
                } catch (e) {
                  await createComment(`è‡ªåŠ¨åˆå¹¶å¤±è´¥ï¼š${e?.message || e}`)
                  return
                }
              }

  verify_and_merge:
    if: ${{ github.event_name == 'issue_comment' && github.event.issue.pull_request && github.event.comment.body == 'å‡†å¤‡å®Œæ¯•' }}
    runs-on: ubuntu-latest
    steps:
      - name: Auto-merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT }}
          script: |
            const owner = context.repo.owner
            const repo = context.repo.repo
            const pull_number = context.payload.issue.number

            const LABEL_FRIEND = 'å‹é“¾'
            const LABEL_SPONSOR = 'èµåŠ©'
            const LABEL_AVATAR_OK = 'å¤´åƒå¯è¾¾'
            const LABEL_AVATAR_BAD = 'å¤´åƒä¸å¯è¾¾'
            const LABEL_SITE_OK = 'ç½‘ç«™å¯è¾¾'
            const LABEL_SITE_BAD = 'ç½‘ç«™ä¸å¯è¾¾'
            const LABEL_ALL_OK = 'URLå…¨éƒ¨å¯è¾¾'
            const LABEL_BIDIR = 'åŒå‘é“¾æ¥éªŒè¯'
            const LABEL_BIDIR_OK = 'åŒå‘é“¾æ¥éªŒè¯é€šè¿‡'

            function isNonEmptyString(v) {
              return typeof v === 'string' && v.trim().length > 0
            }

            async function createComment(body) {
              const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              const footer = `\n\n---\nè¯¥è¯„è®ºç”± Action è‡ªåŠ¨åŒ–å‘é€ï¼Œæ— éœ€å›å¤ã€‚\n\nğŸ”— [æŸ¥çœ‹ Action](${runUrl})`
              const fullBody = body + footer
              await github.rest.issues.createComment({ owner, repo, issue_number: pull_number, body: fullBody })
            }

            function parseJsonSafe(text) {
              try {
                return { ok: true, value: JSON.parse(text) }
              } catch (e) {
                return { ok: false, error: e?.message || String(e) }
              }
            }

            async function getTextFileFromRepo(path, ref) {
              const res = await github.rest.repos.getContent({ owner, repo, path, ref })
              if (Array.isArray(res.data) || !res.data?.content) throw new Error(`Invalid content response for ${path}`)
              const raw = Buffer.from(res.data.content, res.data.encoding || 'base64').toString('utf8')
              return raw
            }

            async function getSiteBase(defaultBranch) {
              try {
                const raw = await getTextFileFromRepo('astro.config.mjs', defaultBranch)
                const m = raw.match(/\bsite\s*:\s*["']([^"']+)["']/)
                if (!m) return null
                return m[1]
              } catch {
                return null
              }
            }

            function normalizeUrl(rawUrl, siteBase) {
              if (!isNonEmptyString(rawUrl)) return null
              const u = rawUrl.trim()
              if (u.startsWith('/')) {
                if (!siteBase) return null
                return new URL(u, siteBase).toString()
              }
              try {
                return new URL(u).toString()
              } catch {
                return null
              }
            }

            async function checkUrl(url, { timeoutMs }) {
              const controller = new AbortController()
              const timer = setTimeout(() => controller.abort(), timeoutMs)
              try {
                const res = await fetch(url, {
                  method: 'GET',
                  redirect: 'follow',
                  headers: {
                    'user-agent': 'fuwari-auto-pr/1.0 (+github actions)',
                    accept: 'text/html,application/json,image/*,*/*;q=0.8',
                  },
                  signal: controller.signal,
                })
                return { ok: res.status >= 200 && res.status < 400, status: res.status }
              } catch (e) {
                return { ok: false, error: e?.message || String(e) }
              } finally {
                clearTimeout(timer)
              }
            }

            async function setLabels({ addLabels, removeLabels, skipIfSame }) {
              const addSet = new Set(addLabels || [])
              const removeSet = new Set(removeLabels || [])
              for (const x of addSet) removeSet.delete(x)

              const current = await github.rest.issues.get({ owner, repo, issue_number: pull_number })
              const currentLabels = new Set((current.data.labels || []).map((l) => l.name))

              if (skipIfSame) {
                for (const name of addSet) {
                  if (currentLabels.has(name)) {
                    core.info(`Label ${name} already set, skip label operations`)
                    return
                  }
                }
              }

              const finalRemove = Array.from(removeSet).filter((name) => currentLabels.has(name))
              if (finalRemove.length) {
                for (const name of finalRemove) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: pull_number, name })
                  } catch (e) {
                    if (e.status !== 404) throw e
                  }
                }
              }

              const finalAdd = Array.from(addSet).filter((name) => !currentLabels.has(name))
              if (finalAdd.length) {
                await github.rest.issues.addLabels({ owner, repo, issue_number: pull_number, labels: finalAdd })
              }
            }

            async function listAllFiles() {
              const files = []
              for await (const res of github.paginate.iterator(
                github.rest.pulls.listFiles,
                { owner, repo, pull_number, per_page: 100 }
              )) {
                for (const f of res.data) files.push(f)
              }
              return files
            }

            const pr = await github.rest.pulls.get({ owner, repo, pull_number })
            core.info(`event_name=${context.eventName}`)
            core.info(`actor=${context.actor}`)
            core.info(`issue_comment_author=${context.payload.comment?.user?.login || ''}`)
            core.info(`pr.number=${pr.data.number}`)
            core.info(`pr.state=${pr.data.state}, pr.draft=${pr.data.draft}`)
            core.info(`pr.user=${pr.data.user?.login || ''}`)
            core.info(`pr.head.ref=${pr.data.head?.ref || ''}`)
            core.info(`pr.head.sha=${pr.data.head?.sha || ''}`)
            core.info(`pr.head.repo.fork=${pr.data.head?.repo?.fork}`)
            core.info(`pr.base.ref=${pr.data.base?.ref || ''}`)
            core.info(`pr.base.repo.private=${pr.data.base?.repo?.private}`)
            core.info(`pr.maintainer_can_modify=${pr.data.maintainer_can_modify}`)
            core.info(`pr.mergeable=${pr.data.mergeable}`)
            core.info(`pr.mergeable_state=${pr.data.mergeable_state}`)
            core.info(`pr.rebaseable=${pr.data.rebaseable}`)
            core.info(`pr.auto_merge=${pr.data.auto_merge ? 'enabled' : 'disabled'}`)
            core.info(`pr.labels=${(pr.data.labels || []).map((l) => l.name).join(',')}`)

            try {
              const auth = await github.rest.apps.getAuthenticated()
              core.info(`authenticated_app=${auth.data?.name || ''}`)
            } catch (e) {
              core.info(`getAuthenticated failed: ${e?.status || ''} ${e?.message || e}`)
            }
            const prLabels = new Set((pr.data.labels || []).map((l) => l.name))
            if (!prLabels.has(LABEL_FRIEND) && !prLabels.has(LABEL_SPONSOR)) {
              core.info('PR is not labeled as å‹é“¾/èµåŠ©. Skip.')
              return
            }
            if (prLabels.has(LABEL_BIDIR) || prLabels.has(LABEL_BIDIR_OK)) {
              await createComment('è¯¥ PR èµ°åŒå‘é“¾æ¥éªŒè¯æµç¨‹ï¼šè¯·åœ¨å‹é“¾ JSON ä¸­å¡«å†™ backlink å­—æ®µå¹¶ push æ›´æ–°ï¼Œæ— éœ€å›å¤â€œå‡†å¤‡å®Œæ¯•â€ã€‚')
              return
            }

            const files = await listAllFiles()

            if (files.length !== 1) {
              await createComment('PR å¿…é¡»ä»…åŒ…å«ä¸€ä¸ªæ–‡ä»¶å˜æ›´ã€‚')
              return
            }
            const file = files[0]
            if (!file.filename.startsWith('src/data/friends/') && !file.filename.startsWith('src/data/sponsors/')) {
              await createComment('åªå…è®¸æ›´æ”¹ src/data/friends/ æˆ– src/data/sponsors/ ä¸‹çš„æ–‡ä»¶ã€‚')
              return
            }
            if (file.status !== 'added' && file.status !== 'modified') {
              await createComment('åªå…è®¸æ–°å¢æˆ–ç¼–è¾‘æ–‡ä»¶ã€‚')
              return
            }

            const relevant = files

            const invalidSuffix = relevant.filter((f) => !f.filename.endsWith('.json')).map((f) => f.filename)
            if (invalidSuffix.length) {
              await createComment(['æ£€æµ‹åˆ°å‹é“¾/èµåŠ©ç›®å½•ä¸‹å­˜åœ¨é .json æ–‡ä»¶ï¼š', '', ...invalidSuffix.map((p) => `- ${p}`)].join('\n'))
              return
            }

            const parsedEntries = []
            const errors = []
            for (const f of relevant) {
              const raw = await getTextFileFromRepo(f.filename, pr.data.head.sha)
              const parsed = parseJsonSafe(raw)
              if (!parsed.ok) {
                errors.push(`${f.filename}: JSON è§£æå¤±è´¥ï¼ˆ${parsed.error}ï¼‰`)
                continue
              }
              if (!parsed.value || typeof parsed.value !== 'object' || Array.isArray(parsed.value)) {
                errors.push(`${f.filename}: JSON å¿…é¡»æ˜¯å¯¹è±¡`)
                continue
              }
              const kind = f.filename.startsWith('src/data/friends/') ? 'friend' : 'sponsor'
              parsedEntries.push({ path: f.filename, kind, data: parsed.value })
            }

            function validateEntry({ kind, data, path }) {
              const entryErrors = []
              if (!isNonEmptyString(data.name)) entryErrors.push('name å¿…å¡«')
              if (!isNonEmptyString(data.avatar)) entryErrors.push('avatar å¿…å¡«')
              if (kind === 'friend') {
                if (!isNonEmptyString(data.url)) entryErrors.push('url å¿…å¡«')
              }
              if (kind === 'sponsor') {
                if (!isNonEmptyString(data.date)) entryErrors.push('date å¿…å¡«')
                if (!isNonEmptyString(data.amount)) entryErrors.push('amount å¿…å¡«')
              }
              if (entryErrors.length) return `${path}: ${entryErrors.join('ã€')}`
              return null
            }

            for (const e of parsedEntries) {
              const err = validateEntry(e)
              if (err) errors.push(err)
            }

            if (errors.length) {
              await createComment(['æ£€æµ‹åˆ°æ•°æ®æ–‡ä»¶æ ¡éªŒå¤±è´¥ï¼š', '', ...errors.map((x) => `- ${x}`)].join('\n'))
              return
            }

            const vipPaths = parsedEntries
              .filter((e) => Object.prototype.hasOwnProperty.call(e.data, 'vip'))
              .map((e) => e.path)
            if (vipPaths.length) {
              await createComment(
                [
                  'æ£€æµ‹åˆ° JSON å­˜åœ¨ vip å­—æ®µï¼Œå·²ç»ˆæ­¢è‡ªåŠ¨æµç¨‹ã€‚',
                  '',
                  'è¯·ä»ä»¥ä¸‹æ–‡ä»¶ç§»é™¤ vip å­—æ®µåå† push æ›´æ–°ï¼Œç„¶åå†æ¬¡å›å¤â€œå‡†å¤‡å®Œæ¯•â€ï¼š',
                  '',
                  ...vipPaths.map((p) => `- ${p}`),
                ].join('\n')
              )
              return
            }

            const primaryKind = prLabels.has(LABEL_SPONSOR) ? 'sponsor' : 'friend'
            const primary = parsedEntries.find((e) => e.kind === primaryKind) || parsedEntries[0]

            await github.rest.pulls.update({
              owner,
              repo,
              pull_number,
              title: `${primary.kind === 'friend' ? 'å‹é“¾' : 'èµåŠ©'}ï¼š${primary.data.name}`,
            })
            const siteBase = await getSiteBase(pr.data.base.repo.default_branch)
            const avatarUrl = normalizeUrl(primary.data.avatar, siteBase)
            const siteUrl = normalizeUrl(primary.data.url, siteBase)
            const selfSite = siteBase ? siteBase.replace(/\/$/, '') : null
            const normalizedSiteUrl = siteUrl ? siteUrl.replace(/\/$/, '') : null
            if (primary.kind === 'friend' && selfSite && normalizedSiteUrl === selfSite) {
              await createComment(`æ£€æµ‹åˆ°å‹é“¾ JSON çš„ url æŒ‡å‘æœ¬ç«™ï¼ˆ${siteBase}ï¼‰ï¼Œè¯·å¡«å†™ä½ è‡ªå·±çš„ç½‘ç«™ URLã€‚`)
              return
            }

            const avatarCheck = avatarUrl ? await checkUrl(avatarUrl, { timeoutMs: 10000 }) : { ok: false, error: 'Invalid avatar URL' }
            const siteCheck =
              primary.kind === 'friend'
                ? siteUrl
                  ? await checkUrl(siteUrl, { timeoutMs: 10000 })
                  : { ok: false, error: 'Invalid site URL' }
                : siteUrl
                  ? await checkUrl(siteUrl, { timeoutMs: 10000 })
                  : null

            const addReach = []
            const removeReach = [LABEL_AVATAR_OK, LABEL_AVATAR_BAD, LABEL_SITE_OK, LABEL_SITE_BAD, LABEL_ALL_OK]

            addReach.push(avatarCheck.ok ? LABEL_AVATAR_OK : LABEL_AVATAR_BAD)
            if (siteCheck) addReach.push(siteCheck.ok ? LABEL_SITE_OK : LABEL_SITE_BAD)

            const allOk = avatarCheck.ok && (!siteCheck || siteCheck.ok)
            if (allOk && siteCheck) addReach.push(LABEL_ALL_OK)

            await setLabels({ addLabels: addReach, removeLabels: removeReach, skipIfSame: true })

            if (!avatarCheck.ok || (siteCheck && !siteCheck.ok)) {
              await createComment('æ£€æµ‹åˆ°é“¾æ¥ä¸å¯è¾¾ï¼Œè¯·ä¿®å¤åå†æ¬¡å›å¤â€œå‡†å¤‡å®Œæ¯•â€ã€‚')
              return
            }

            try {
              await github.rest.pulls.merge({ owner, repo, pull_number, merge_method: 'squash' })
            } catch (e) {
              core.error(`merge failed: status=${e?.status || ''}`)
              core.error(`merge failed: message=${e?.message || e}`)
              try {
                core.error(`merge failed: response=${JSON.stringify(e?.response?.data || null)}`)
              } catch {}
              await createComment(
                [
                  'è‡ªåŠ¨åˆå¹¶å¤±è´¥ã€‚',
                  '',
                  `é”™è¯¯ä¿¡æ¯ï¼š${e?.message || e}`,
                  `HTTP çŠ¶æ€ï¼š${e?.status || 'unknown'}`,
                  `å“åº”ï¼š${(() => { try { return JSON.stringify(e?.response?.data || null) } catch { return 'unavailable' } })()}`,
                ].join('\n')
              )
              return
            }


---
---

<script>
	import * as Diff from "diff";

	const NOTIFICATION_STATE_KEY = "fuwari-notification-state";
	const DEBUG_PARAM_KEY = "__diff_debug";
	const DEBUG_STATE_KEY = "fuwari-diff-debug-state";
	const CONTEXT_LINES = 2;
	const BASE_URL = import.meta.env.BASE_URL || "/";

	function normalizeGuid(guid, link) {
		const value = (guid || link || "").trim();
		if (!value) return "";
		try {
			const url = new URL(value, window.location.origin);
			return `${url.pathname}${url.search}${url.hash}`;
		} catch {
			return value;
		}
	}

	function getRelativePath(absoluteUrl) {
		try {
			const url = new URL(absoluteUrl, window.location.origin);
			return `${url.pathname}${url.search}${url.hash}`;
		} catch {
			return absoluteUrl;
		}
	}

	function normalizePathname(pathname) {
		const p = String(pathname || "");
		if (!p) return "/";
		const noQueryHash = p.split("#")[0].split("?")[0];
		if (noQueryHash.length > 1) return noQueryHash.replace(/\/+$/, "");
		return "/";
	}

	function stripBasePath(pathname) {
		const base = normalizePathname(BASE_URL);
		const p = normalizePathname(pathname);
		if (!base || base === "/") return p;
		if (p === base) return "/";
		if (p.startsWith(`${base}/`)) return p.slice(base.length) || "/";
		return p;
	}

	function clearInlineDiff(container) {
		container.querySelectorAll("[data-post-inline-diff-inline]").forEach((el) => {
			if (!(el instanceof HTMLElement)) return;
			const kind = el.getAttribute("data-post-inline-diff-inline") || "";
			if (kind === "anchor") {
				el.remove();
				return;
			}
			if (kind === "add") {
				el.remove();
				return;
			}
			const text = document.createTextNode(el.textContent || "");
			el.replaceWith(text);
		});

		container.querySelectorAll("[data-post-inline-diff]").forEach((el) => el.remove());
		container
			.querySelectorAll("[data-post-inline-diff-add-target]")
			.forEach((el) => el.removeAttribute("data-post-inline-diff-add-target"));
		container.querySelectorAll(".post-inline-diff-add-target").forEach((el) => el.classList.remove("post-inline-diff-add-target"));
		container
			.querySelectorAll("[data-post-inline-diff-add-target-img]")
			.forEach((el) => el.removeAttribute("data-post-inline-diff-add-target-img"));
		container.querySelectorAll(".post-inline-diff-add-target-img").forEach((el) => el.classList.remove("post-inline-diff-add-target-img"));
		container
			.querySelectorAll("[data-post-inline-diff-del-target]")
			.forEach((el) => el.removeAttribute("data-post-inline-diff-del-target"));
		container.querySelectorAll(".post-inline-diff-del-target").forEach((el) => el.classList.remove("post-inline-diff-del-target"));
		container
			.querySelectorAll("[data-post-inline-diff-del-target-img]")
			.forEach((el) => el.removeAttribute("data-post-inline-diff-del-target-img"));
		container.querySelectorAll(".post-inline-diff-del-target-img").forEach((el) => el.classList.remove("post-inline-diff-del-target-img"));
	}

	function buildRows(diffParts) {
		/** @type {{type: 'add'|'del'|'ctx', text: string}[]} */
		const rows = [];

		for (const part of diffParts) {
			const type = part?.added ? "add" : part?.removed ? "del" : "ctx";
			const value = String(part?.value ?? "");
			const lines = value.split("\n");
			if (lines.length > 0 && lines[lines.length - 1] === "") lines.pop();
			for (const line of lines) rows.push({ type, text: line });
		}

		return rows;
	}

	function sliceWithContext(rows) {
		const changeIndexes = [];
		for (let i = 0; i < rows.length; i += 1) {
			if (rows[i].type !== "ctx") changeIndexes.push(i);
		}
		if (changeIndexes.length === 0) return [];

		const keep = new Array(rows.length).fill(false);
		for (const idx of changeIndexes) {
			const start = Math.max(0, idx - CONTEXT_LINES);
			const end = Math.min(rows.length - 1, idx + CONTEXT_LINES);
			for (let i = start; i <= end; i += 1) keep[i] = true;
		}

		/** @type {(typeof rows[number] | {type: 'gap', text: string})[]} */
		const out = [];
		let inGap = false;
		for (let i = 0; i < rows.length; i += 1) {
			if (keep[i]) {
				out.push(rows[i]);
				inGap = false;
				continue;
			}
			if (!inGap) {
				out.push({ type: "gap", text: "…" });
				inGap = true;
			}
		}

		return out;
	}

	function toHunks(rowsWithGaps) {
		/** @type {{type: 'add'|'del'|'ctx', text: string}[][]} */
		const hunks = [];
		/** @type {{type: 'add'|'del'|'ctx', text: string}[]} */
		let current = [];

		for (const row of rowsWithGaps) {
			if (row.type === "gap") {
				if (current.length) hunks.push(current);
				current = [];
				continue;
			}
			current.push(row);
		}
		if (current.length) hunks.push(current);
		return hunks;
	}

	function normalizeLineText(text) {
		return String(text ?? "")
			.replace(/\r\n/g, "\n")
			.replace(/\r/g, "\n")
			.replace(/\u00A0/g, " ")
			.replace(/[ \t]*\n[ \t]*/g, " ")
			.replace(/[ \t]{2,}/g, " ")
			.replace(/[ \t]+$/g, "")
			.trim();
	}

	function extractImgSrc(line) {
		const s = String(line ?? "");
		const m = s.match(/<img[^>]*\s(?:src|data-src)=["']([^"']+)["']/i);
		return m?.[1] ? String(m[1]).trim() : null;
	}

	function stripHtmlLine(line) {
		const tmp = document.createElement("div");
		tmp.innerHTML = String(line ?? "");
		return tmp.textContent || tmp.innerText || "";
	}

	function normalizeForMatch(line) {
		const text = normalizeLineText(stripHtmlLine(line));
		if (text) return { kind: "text", value: text };
		const imgSrc = extractImgSrc(line);
		if (imgSrc) return { kind: "img", value: imgSrc };
		const raw = normalizeLineText(line);
		if (raw) return { kind: "text", value: raw };
		return { kind: "none", value: "" };
	}

	function decodeHtmlEntities(value) {
		const t = document.createElement("textarea");
		t.innerHTML = String(value ?? "");
		return t.value;
	}

	function normalizeUrlForCompare(raw) {
		const v = decodeHtmlEntities(String(raw ?? "").trim());
		if (!v) return "";
		try {
			const url = new URL(v, window.location.origin);
			const entries = Array.from(url.searchParams.entries()).sort((a, b) => {
				const k = String(a[0]).localeCompare(String(b[0]));
				if (k !== 0) return k;
				return String(a[1]).localeCompare(String(b[1]));
			});
			const qs = entries
				.map(([k, val]) => `${encodeURIComponent(k)}=${encodeURIComponent(val)}`)
				.join("&");
			return `${url.pathname}${qs ? `?${qs}` : ""}`;
		} catch {
			return v;
		}
	}

	function findImgBySrc(container, src) {
		const normPath = normalizeUrlForCompare(src);
		if (!normPath) return null;
		const imgs = container.querySelectorAll("img");
		for (const img of imgs) {
			if (!(img instanceof HTMLImageElement)) continue;
			let cand = img.getAttribute("src") || img.getAttribute("data-src") || "";
			let candPath = normalizeUrlForCompare(cand);
			if (candPath === normPath) return img;
			if (candPath && normPath && (candPath.includes(normPath) || normPath.includes(candPath))) return img;
		}
		return null;
	}

	function getBlockList(container) {
		return Array.from(container.querySelectorAll("p, li, blockquote, pre, h1, h2, h3, h4, h5, h6, img")).filter((el) => el instanceof HTMLElement);
	}

	function findContextBefore(container, hunk, rowIndex) {
		for (let i = rowIndex - 1; i >= 0; i -= 1) {
			const row = hunk[i];
			if (row?.type !== "ctx") continue;
			const el = findBlockByText(container, row.text);
			if (el) return el;
		}
		return null;
	}

	function findContextAfter(container, hunk, rowIndex) {
		for (let i = rowIndex + 1; i < hunk.length; i += 1) {
			const row = hunk[i];
			if (row?.type !== "ctx") continue;
			const el = findBlockByText(container, row.text);
			if (el) return el;
		}
		return null;
	}

	function lineExistsInArticle(container, line) {
		const key = normalizeForMatch(line);
		if (key.kind === "img") return !!findImgBySrc(container, key.value);
		if (key.kind !== "text") return false;
		return !!findBlockByText(container, line);
	}

	function findBlockByText(container, line) {
		const key = normalizeForMatch(line);
		if (key.kind !== "text") return null;
		const needle = key.value.slice(0, 48);
		const blocks = container.querySelectorAll("p, li, blockquote, pre, h1, h2, h3, h4, h5, h6");
		for (const el of blocks) {
			if (!(el instanceof HTMLElement)) continue;
			if (el.closest(".post-inline-diff-add-line")) continue;
			if (el.closest(".post-inline-diff-del-line")) continue;
			if (el.classList.contains("post-inline-diff-del-target")) continue;
			const content = el.textContent || "";
			if (!normalizeLineText(content).includes(needle)) continue;
			return el;
		}

		return null;
	}

	function findAnchorElement(container, hunk) {
		const pick = (row) => String(row?.text ?? "").trim();
		const ctx = hunk.find((r) => r.type === "ctx" && pick(r).length >= 6);
		const anchorLine = ctx?.text ?? ""; 
		if (!anchorLine) return null;
		
		const key = normalizeForMatch(anchorLine);
		if (key.kind === "img") return findImgBySrc(container, key.value);
		return findBlockByText(container, anchorLine);
	}

	function createDeletionNode(text, includeAnchor, useListItem) {
		const el = document.createElement(useListItem ? "li" : "div");
		el.setAttribute("data-post-inline-diff", "1");
		el.className = "post-inline-diff-del-line";

		if (includeAnchor) {
			const anchor = document.createElement("span");
			anchor.id = "post-diff";
			anchor.setAttribute("data-post-inline-diff", "1");
			el.appendChild(anchor);
		}

		const del = document.createElement("del");
		const raw = normalizeLineText(text);
		if (shouldRenderLineAsHtml(raw)) del.innerHTML = " " + sanitizeHtmlFragment(raw);
		else del.textContent = ` ${raw}`;

		el.appendChild(del);
		return el;
	}

	function sanitizeHtmlFragment(html) {
		const parser = new DOMParser();
		const doc = parser.parseFromString(`<div>${String(html || "")}</div>`, "text/html");
		const root = doc.body.firstElementChild;
		if (!root) return String(html || "");

		const scripts = root.querySelectorAll("script, iframe, object, embed, style");
		scripts.forEach(el => el.remove());

		const all = root.querySelectorAll("*");
		all.forEach(el => {
			const attrs = Array.from(el.attributes);
			for (const attr of attrs) {
				if (attr.name.startsWith("on")) el.removeAttribute(attr.name);
			}
		});

		return root.innerHTML;
	}

	function shouldRenderLineAsHtml(line) {
		const t = String(line || "").trim();
		return /<[a-z][\s\S]*>/i.test(t) || /<\/[a-z][\s\S]*>/i.test(t);
	}

	function createAdditionNode(text, includeAnchor, useListItem) {
		const el = document.createElement(useListItem ? "li" : "div");
		el.setAttribute("data-post-inline-diff", "1");
		el.className = "post-inline-diff-add-line";

		if (includeAnchor) {
			const anchor = document.createElement("span");
			anchor.id = "post-diff";
			anchor.setAttribute("data-post-inline-diff", "1");
			el.appendChild(anchor);
		}

		const content = document.createElement("div");
		content.className = "post-inline-diff-add-content";

		const raw = String(text ?? "").trim();
		if (shouldRenderLineAsHtml(raw)) content.innerHTML = sanitizeHtmlFragment(raw);
		else content.textContent = raw;

		el.appendChild(content);
		return el;
	}

	function insertAfter(node, ref) {
		const parent = ref?.parentNode;
		if (!parent) return false;
		parent.insertBefore(node, ref.nextSibling);
		return true;
	}

	function parseHtmlSingleElement(html) {
		const parser = new DOMParser();
		const doc = parser.parseFromString(`<div>${String(html || "")}</div>`, "text/html");
		return doc.body.firstElementChild?.firstElementChild;
	}

	function applyInlineTextDiff(targetTextNodes, oldText, newText, anchorState) {
		return false;
	}

	function tryApplyInlineReplace(targetEl, oldHtml, newHtml, anchorState) {
		return false;
	}

	function applyInlineDiff(container, diffParts, isDebug) {
		clearInlineDiff(container);
		const rows = buildRows(diffParts);
		const focused = sliceWithContext(rows);
		const hunks = toHunks(focused);

		const anchorState = { inserted: false };
		for (const hunk of hunks) {
			const insertionPoint = findAnchorElement(container, hunk);
			let idx = 0;
			while (idx < hunk.length) {
				const row = hunk[idx];
				if (idx + 1 < hunk.length) {
					const next = hunk[idx + 1];
					const isReplace = (row.type === "del" && next.type === "add") || (row.type === "add" && next.type === "del");
					if (isReplace) {
						const oldHtml = row.type === "del" ? row.text : next.text;
						const newHtml = row.type === "add" ? row.text : next.text;
						const oldKey = normalizeForMatch(oldHtml);
						const newKey = normalizeForMatch(newHtml);
						let target = null;
						let isImgReplace = false;
						
						if (newKey.kind === "img") {
							target = findImgBySrc(container, newKey.value);
							isImgReplace = true;
						} else {
							target = findBlockByText(container, newHtml);
						}
						
						if (target instanceof HTMLElement) {
							if (isImgReplace) {
								target.classList.add("post-inline-diff-add-target-img");
								target.setAttribute("data-post-inline-diff-add-target-img", "1");
							} else {
								target.classList.add("post-inline-diff-add-target");
								target.setAttribute("data-post-inline-diff-add-target", "1");
							}
							const t = oldKey.kind === "img" ? `[图片] ${oldKey.value}` : oldKey.value;
							const node = createDeletionNode(t, !anchorState.inserted, false);
							if (!anchorState.inserted) anchorState.inserted = true;
							target.parentNode?.insertBefore(node, target);
							idx += 2;
							continue;
						}
					}
				}

				if (row.type === "add") {
					let endIdx = idx;
					while (endIdx + 1 < hunk.length && hunk[endIdx + 1].type === "add") {
						endIdx++;
					}
					for (let i = idx; i <= endIdx; i++) {
						const addRow = hunk[i];
						const key = normalizeForMatch(addRow.text);
						if (key.kind === "img") {
							const img = findImgBySrc(container, key.value);
							if (img instanceof HTMLElement) {
								img.classList.add("post-inline-diff-add-target-img");
								img.setAttribute("data-post-inline-diff-add-target-img", "1");
								if (!anchorState.inserted) {
									const anchor = document.createElement("span");
									anchor.id = "post-diff";
									anchor.setAttribute("data-post-inline-diff", "1");
									img.parentNode?.insertBefore(anchor, img);
									anchorState.inserted = true;
								}
							}
						} else {
							const target = findBlockByText(container, addRow.text);
							if (target instanceof HTMLElement) {
								target.classList.add("post-inline-diff-add-target");
								target.setAttribute("data-post-inline-diff-add-target", "1");
								if (!anchorState.inserted) {
									const anchor = document.createElement("span");
									anchor.id = "post-diff";
									anchor.setAttribute("data-post-inline-diff", "1");
									target.parentNode?.insertBefore(anchor, target);
									anchorState.inserted = true;
								}
							}
						}
					}
					idx = endIdx + 1;
					continue;
				}

				if (row.type !== "del") {
					idx += 1;
					continue;
				}

				const key = normalizeForMatch(row.text);
				if (key.kind === "none") {
					idx += 1;
					continue;
				}

				if (lineExistsInArticle(container, row.text)) {
					if (key.kind === "img") {
						const img = findImgBySrc(container, key.value);
						if (img instanceof HTMLElement) {
							img.classList.add("post-inline-diff-del-target-img");
							img.setAttribute("data-post-inline-diff-del-target-img", "1");
						}
						idx += 1;
						continue;
					}
					const target = findBlockByText(container, row.text);
					if (target instanceof HTMLElement) {
						target.classList.add("post-inline-diff-del-target");
						target.setAttribute("data-post-inline-diff-del-target", "1");
					}
					idx += 1;
					continue;
				}

				const t = key.kind === "img" ? `[图片] ${key.value}` : key.value;

				let inserted = false;

				for (let i = idx - 1; i >= 0; i -= 1) {
					const prev = hunk[i];
					if (prev?.type !== "ctx") continue;
					const ctxEl = findBlockByText(container, prev.text);
					if (!(ctxEl instanceof HTMLElement)) continue;
					const useListItem = ctxEl.tagName === "LI";
					const node = createDeletionNode(t, !anchorState.inserted, useListItem);
					if (!anchorState.inserted) anchorState.inserted = true;
					inserted = insertAfter(node, ctxEl);
					break;
				}

				if (!inserted) {
					for (let i = idx + 1; i < hunk.length; i += 1) {
						const next = hunk[i];
						if (next?.type !== "ctx") continue;
						const ctxEl = findBlockByText(container, next.text);
						if (!(ctxEl instanceof HTMLElement)) continue;
						const useListItem = ctxEl.tagName === "LI";
						const node = createDeletionNode(t, !anchorState.inserted, useListItem);
						if (!anchorState.inserted) anchorState.inserted = true;
						ctxEl.parentNode?.insertBefore(node, ctxEl);
						inserted = true;
						break;
					}
				}

				if (!inserted) {
					const useListItem = insertionPoint?.tagName === "LI";
					const node = createDeletionNode(t, !anchorState.inserted, useListItem);
					if (!anchorState.inserted) anchorState.inserted = true;
					if (insertionPoint?.parentNode) insertionPoint.parentNode.insertBefore(node, insertionPoint);
					else container.prepend(node);
				}

				idx += 1;
			}
		}
	}

	function applySimpleDiff(container, diffParts) {
		container.innerHTML = "";
		const rows = buildRows(diffParts);
		
		for (const row of rows) {
			if (row.type === "ctx") {
				const span = document.createElement("span");
				span.textContent = row.text;
				container.appendChild(span);
			} else if (row.type === "add") {
				const span = document.createElement("span");
				span.className = "post-inline-diff-add-target";
				span.textContent = row.text;
				if (!container.querySelector("#post-diff")) {
					const anchor = document.createElement("span");
					anchor.id = "post-diff";
					container.appendChild(anchor);
				}
				container.appendChild(span);
			} else if (row.type === "del") {
				const span = document.createElement("span");
				span.className = "post-inline-diff-del-target";
				span.textContent = row.text;
				container.appendChild(span);
			}
		}
	}

	function initPostInlineDiff() {
		const sp = new URLSearchParams(window.location.search);
		const isDebug = sp.get(DEBUG_PARAM_KEY) === "1";

		const stateStr = isDebug ? sessionStorage.getItem(DEBUG_STATE_KEY) : localStorage.getItem(NOTIFICATION_STATE_KEY);
		if (!stateStr) {
			return;
		}

		let state;
		try {
			state = JSON.parse(stateStr);
		} catch {
            const content = document.querySelector(".markdown-content");
            if (content instanceof HTMLElement) clearInlineDiff(content);
			return;
		}

		const items = Array.isArray(state?.items) ? state.items : [];
		const currentPath = normalizePathname(window.location.pathname);
		const currentStripped = stripBasePath(currentPath);
		const currentCandidates = new Set([currentPath, currentStripped]);

		const matched = items.find((post) => {
			if (!post?.isUpdated || !post?.diff) return false;
			const guidPath = normalizePathname(normalizeGuid(post.guid, post.link));
			const linkPath = normalizePathname(getRelativePath(post.link));
			const postCandidates = [guidPath, linkPath, stripBasePath(guidPath), stripBasePath(linkPath)];
			return postCandidates.some((p) => currentCandidates.has(p));
		});

		const shouldApply = isDebug || sp.get("diff") === "1" || window.location.hash === "#post-diff";

		if (!shouldApply || !matched?.diff) {
            const content = document.querySelector(".markdown-content");
            if (content instanceof HTMLElement) clearInlineDiff(content);
			return;
		}

        const diffType = matched.diffType || 'composite';
        
        let diffData = matched.diff;
        
        if (Array.isArray(diffData)) {
            if (diffType === 'title') diffData = { title: diffData };
            else if (diffType === 'description') diffData = { description: diffData };
            else diffData = { content: diffData };
        } else if (diffData.diff && (diffData.diffType === 'composite' || diffData.diffType === undefined)) {
            diffData = diffData.diff;
        }

        if (diffData.title) {
            const container = document.getElementById('post-title');
            if (container) applySimpleDiff(container, diffData.title);
        }
        
        if (diffData.description) {
            const container = document.getElementById('post-description');
            if (container) applySimpleDiff(container, diffData.description);
        }
        
        if (diffData.content) {
            const container = document.querySelector(".markdown-content");
            if (container) applyInlineDiff(container, diffData.content, isDebug);
        }

		const anchor = document.getElementById("post-diff");
		if (anchor instanceof HTMLElement) anchor.scrollIntoView({ behavior: "smooth", block: "start" });
	}

	if (!(window).__fuwariPostInlineDiffBound) {
		document.addEventListener("DOMContentLoaded", initPostInlineDiff);
		document.addEventListener("swup:contentReplaced", initPostInlineDiff);
		window.addEventListener("fuwari:diff-debug-updated", initPostInlineDiff);
	}
</script>

<style is:global>
	.post-inline-diff-add-target {
		text-decoration-line: underline;
		text-decoration-thickness: 2px;
		text-underline-offset: 0.18em;
		text-decoration-color: rgb(22 163 74 / 1);
	}

	:global(.dark) .post-inline-diff-add-target {
		text-decoration-color: rgb(134 239 172 / 1);
	}

	.post-inline-diff-add-target-img {
		outline: 2px solid rgb(22 163 74 / 1);
		outline-offset: 2px;
		border-radius: 0.5rem;
	}

	:global(.dark) .post-inline-diff-add-target-img {
		outline-color: rgb(134 239 172 / 1);
	}

	.post-inline-diff-del-line {
		margin: 0.5rem 0;
		color: rgb(220 38 38 / 1);
	}

	:global(.dark) .post-inline-diff-del-line {
		color: rgb(252 165 165 / 1);
	}

	.post-inline-diff-del-line del {
		text-decoration-thickness: 2px;
	}

	.post-inline-diff-add-line {
		margin: 0.5rem 0;
		color: rgb(22 163 74 / 1);
	}

	:global(.dark) .post-inline-diff-add-line {
		color: rgb(134 239 172 / 1);
	}

	.post-inline-diff-add-line .post-inline-diff-add-content {
		display: inline-block;
		vertical-align: top;
		text-decoration-line: underline;
		text-decoration-thickness: 2px;
	}

	.post-inline-diff-add-line img,
	.post-inline-diff-add-content img {
		outline: 2px solid rgb(22 163 74 / 1);
		outline-offset: 2px;
		border-radius: 0.5rem;
		background-color: rgba(22, 163, 74, 0.1);
	}

	:global(.dark) .post-inline-diff-add-line img,
	:global(.dark) .post-inline-diff-add-content img {
		outline-color: rgb(134 239 172 / 1);
		background-color: rgba(134, 239, 172, 0.1);
	}

	.post-inline-diff-del-line.post-inline-diff-del-line {
		list-style: none;
	}

	.post-inline-diff-del-line img,
	.post-inline-diff-del-line del img {
		outline: 2px solid rgb(220 38 38 / 1);
		outline-offset: 2px;
		border-radius: 0.5rem;
		opacity: 0.8;
	}

	:global(.dark) .post-inline-diff-del-line img,
	:global(.dark) .post-inline-diff-del-line del img {
		outline-color: rgb(252 165 165 / 1);
	}

	.post-inline-diff-del-target {
		color: rgb(220 38 38 / 1) !important;
		text-decoration-line: line-through;
		text-decoration-thickness: 2px;
		text-decoration-color: rgb(220 38 38 / 1);
	}

	:global(.dark) .post-inline-diff-del-target {
		color: rgb(252 165 165 / 1) !important;
		text-decoration-color: rgb(252 165 165 / 1);
	}

	h1.post-inline-diff-del-target,
	h2.post-inline-diff-del-target,
	h3.post-inline-diff-del-target,
	h4.post-inline-diff-del-target,
	h5.post-inline-diff-del-target,
	h6.post-inline-diff-del-target {
		color: rgb(220 38 38 / 1) !important;
		text-decoration-color: rgb(220 38 38 / 1);
	}

	:global(.dark) h1.post-inline-diff-del-target,
	:global(.dark) h2.post-inline-diff-del-target,
	:global(.dark) h3.post-inline-diff-del-target,
	:global(.dark) h4.post-inline-diff-del-target,
	:global(.dark) h5.post-inline-diff-del-target,
	:global(.dark) h6.post-inline-diff-del-target {
		color: rgb(252 165 165 / 1) !important;
		text-decoration-color: rgb(252 165 165 / 1);
	}

	.post-inline-diff-del-target-img {
		outline: 2px solid rgb(220 38 38 / 1);
		outline-offset: 2px;
		border-radius: 0.5rem;
	}

	:global(.dark) .post-inline-diff-del-target-img {
		outline-color: rgb(252 165 165 / 1);
	}
</style>
